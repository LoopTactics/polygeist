// RUN: plugin-opt %s --show-mlir | FileCheck %s

// CHECK: #map0 = affine_map<(d0, d1) -> ()>
// CHECK-NEXT: #map1 = affine_map<(d0, d1) -> (d0, d1)>
// CHECK-NEXT: #map2 = affine_map<(d0, d1, d2) -> ()>
// CHECK-NEXT: #map3 = affine_map<(d0, d1, d2) -> (d0, d2)>
// CHECK-NEXT: #map4 = affine_map<(d0, d1, d2) -> (d2, d1)>
// CHECK-NEXT: #map5 = affine_map<(d0, d1, d2) -> (d0, d1)>
// CHECK-NEXT: module  {
// CHECK-NEXT:  func private @gemm(%arg0: f32, %arg1: f32, %arg2: tensor<?x?xf32>, %arg3: tensor<?x?xf32>, %arg4: tensor<?x?xf32>) {
// CHECK-NEXT:    %cst = constant 1.000000e+00 : f32
// CHECK-NEXT:    %0 = linalg.fill(%cst, %arg4) : f32, tensor<?x?xf32> -> tensor<?x?xf32> 
// CHECK-NEXT:    %1 = linalg.generic {indexing_maps = [#map0, #map1], iterator_types = ["parallel", "parallel"]} ins(%arg1 : f32) outs(%arg4 : tensor<?x?xf32>) {
// CHECK-NEXT:    ^bb0(%arg5: f32, %arg6: f32):  // no predecessors
// CHECK-NEXT:      %3 = mulf %arg5, %arg6 : f32
// CHECK-NEXT:      linalg.yield %3 : f32
// CHECK-NEXT:    } -> tensor<?x?xf32>
// CHECK-NEXT:    %2 = linalg.generic {indexing_maps = [#map2, #map3, #map4, #map5], iterator_types = ["parallel", "parallel", "reduction"]} ins(%arg0, %arg2, %arg3 : f32, tensor<?x?xf32>, tensor<?x?xf32>) outs(%arg4 : tensor<?x?xf32>) {
// CHECK-NEXT:    ^bb0(%arg5: f32, %arg6: f32, %arg7: f32, %arg8: f32):  // no predecessors
// CHECK-NEXT:      %3 = mulf %arg5, %arg6 : f32
// CHECK-NEXT:      %4 = mulf %3, %arg7 : f32
// CHECK-NEXT:      %5 = addf %4, %arg8 : f32
// CHECK-NEXT:      linalg.yield %5 : f32
// CHECK-NEXT:    } -> tensor<?x?xf32>
// CHECK-NEXT:    return
// CHECK-NEXT:  }
// CHECK-NEXT: }


__start_tc

def gemm(float32 a, float32 b, float32(N, M) A, float32(M, K) B) -> (float32(N, K) C)
{
  C(i,j) *=! b
  C(i,j) += a * A(i,k) * B(k,j)
}
